---
title: ğŸ” TLS Integration
description: Secure your Zuno applications with built-in TLS support using OpenSSL.
---

import { Code } from '@astrojs/starlight/components';

Zuno includes native support for **TLS (Transport Layer Security)** using OpenSSL. This allows you to serve HTTPS traffic directly from your application without needing an external reverse proxy.

---

## ğŸ§° Requirements

To use TLS in Zuno, make sure:

- OpenSSL is installed and available on your system.
- Your application is compiled with TLS support enabled (Zuno does this by default).
- You have access to a valid certificate and private key.

---

## ğŸ“„ Certificate Files

You will need two files (or more if using mTLS):

- `server.cert`: Your public certificate (can be self-signed or from a CA)
- `server.key`: Your private key

To generate a self-signed certificate for development:

<Code title="Generate Self-Signed Cert" lang="bash" code={`openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.cert -days 365 -nodes`} />

This will prompt you for certificate details and generate both files in the current directory.

---

## ğŸš€ Enabling TLS in Zuno

Use `app.useTLS(config)` to enable TLS before calling `app.listen(port)`. The `TLSConfig` struct contains all necessary fields.

<Code title="main_tls.cpp" lang="cpp" code={`#include <zuno/zuno.hpp>

int main() {
  zuno::App app;

  app.useTLS({
    .certFile = "server.cert",
    .keyFile = "server.key"
  });

  app.get("/", [](auto req, auto res) {
    res.send("Secure Hello from Zuno!");
  });

  app.listen(443);
}`}/>

Once running, you can access your app via `https://localhost`.

---

## ğŸ§ª Verifying TLS

You can test your TLS server using `curl`:

<Code lang="bash" code={`curl -k https://localhost`} />

The `-k` flag tells curl to ignore certificate verification (useful for self-signed certs).

---

## ğŸ§± TLSConfig Structure

The `TLSConfig` struct supports the following fields:

| Field | Type | Description |
|-------|------|-------------|
| `certFile` | `std::string` | Path to the public certificate file |
| `keyFile` | `std::string` | Path to the private key file |
| `dhParamsFile` _(optional)_ | `std::string` | Path to a DH params file for forward secrecy |
| `requireClientCert` _(optional)_ | `bool` | Enable mutual TLS (default: `false`) |
| `caCertFile` _(optional)_ | `std::string` | CA certificate to verify client certs (used with mTLS) |

---

## ğŸ¤ Enabling Mutual TLS (mTLS)

To require client certificates, set `requireClientCert = true` and provide a `caCertFile`:

<Code title="mtls.cpp" lang="cpp" code={`app.useTLS({
  .certFile = "server.cert",
  .keyFile = "server.key",
  .requireClientCert = true,
  .caCertFile = "ca.cert"
});`} />

This will reject any client that does not present a valid certificate signed by your CA.

---

## ğŸ” Best Practices

- Use certificates from a trusted Certificate Authority (CA) in production.
- Redirect HTTP traffic to HTTPS using a middleware.
- Rotate certificates regularly and monitor expiration dates.
- Use strong ciphers and disable outdated protocols (e.g. TLS 1.0/1.1).
- For mTLS, validate client identity and permissions after handshake.

---

## ğŸ§° Example: Redirect HTTP to HTTPS

You can run both HTTP and HTTPS servers and redirect insecure traffic:

<Code title="redirect.cpp" lang="cpp" code={`app.use([](auto req, auto res, auto next) {
  if (!req.is_secure()) {
    std::string redirect_url = "https://" + req.header("Host") + req.url();
    res.status(301).redirect(redirect_url);
    return;
  }
  next();
});`} />

---

## ğŸ” Next Steps

Now that your app is secure, you can explore:

- [Error Handling](/error-handling) â€” Gracefully handle TLS errors and exceptions.
- [Deployment](/deployment) â€” Learn how to deploy your Zuno app in production.
- [Middleware](/middleware) â€” Use middleware to enforce HTTPS or log secure requests.
