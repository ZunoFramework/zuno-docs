---
title: üß† Architecture Overview
description: Understand how Zuno is structured internally and how its components interact.
---

import { Code } from '@astrojs/starlight/components';

# üß† Architecture Overview

Zuno is a modern C++ web framework designed for performance, modularity, and clarity. It draws inspiration from minimalist web frameworks, but is built entirely in C++20 with a focus on native performance and explicit control.

---

## üß© Core Components

Zuno is composed of a few essential building blocks:

### 1. `zuno::App`

This is the main application object. It manages:

- Route registration
- Middleware execution
- Server configuration (including TLS)

<Code lang="cpp" title="app.cpp" code={`zuno::App app;

app.get("/", [](auto req, auto res) {
  res.send("Hello from Zuno");
});

app.listen(8080);`} />

---

### 2. Route Registration

Zuno supports HTTP methods like `GET`, `POST`, `PUT`, and `DELETE` directly on the `App` instance. Each route is registered with a path and a handler function.

<Code lang="cpp" title="routes.cpp" code={`app.get("/status", [](auto req, auto res) {
  res.send("OK");
});

app.post("/submit", [](auto req, auto res) {
  res.send("Data received");
});`} />

Currently, Zuno does not support nested routers, but you can organize your routes manually by grouping them in separate files or functions.

---

### 3. Middleware Pipeline

Zuno supports middleware functions that are executed in the order they are registered. Each middleware receives the request, response, and a `next()` function to pass control.

<Code lang="cpp" title="middleware.cpp" code={`app.use([](auto req, auto res, auto next) {
  std::cout << "[LOG] " << req.method() << " " << req.path() << std::endl;
  next();
});`} />

Middleware can be used for logging, authentication, request parsing, and more.

---

### 4. Request & Response Abstractions

Zuno provides expressive interfaces for working with HTTP requests and responses:

- `req.method()`, `req.path()`, `req.body()`
- `res.send()`, `res.status()`, `res.json()`

<Code lang="cpp" title="echo.cpp" code={`app.post("/echo", [](auto req, auto res) {
  auto body = req.body();
  res.send(body);
});`} />

---

### 5. Asynchronous Core (Asio)

Zuno is built on top of [Asio standalone](https://think-async.com/Asio/), a powerful asynchronous I/O library. This enables:

- Non-blocking request handling
- High concurrency with minimal threads
- Efficient resource usage

---

### 6. TLS Integration

Zuno includes native support for TLS using OpenSSL. You can serve HTTPS traffic directly from your app:

<Code lang="cpp" title="tls.cpp" code={`app.useTLS({
  "cert.pem",
  "key.pem"
});

app.listen(443);
`} />

---

## üß± Layered Design

Zuno follows a clean, layered architecture:

<Code lang='mermaid' title='Layered Architecture' code={`
[ Application Layer ] --> Routes, Middleware [ HTTP Engine ] --> Path matching, method dispatch [ Asio Core ] --> Event loop, socket handling [ TLS Layer (optional)] --> Secure transport via OpenSSL
`} />


---

## üß† Design Philosophy

- **Minimal by default, powerful by design**
- **No macros, no magic ‚Äî just modern C++**
- **Composable and testable**
- **Performance-first, without sacrificing ergonomics**

---

## üîç Next Steps

Now that you understand how Zuno is structured, you can dive deeper into:

- [Routing](/routing)
- [Middleware](/middleware)
- [TLS Integration](/tls)
- [Request & Response](/request-response)
